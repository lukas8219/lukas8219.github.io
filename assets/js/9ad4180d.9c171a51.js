"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5116],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>d});var s=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);t&&(s=s.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,s)}return a}function n(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,s,i=function(e,t){if(null==e)return{};var a,s,i={},r=Object.keys(e);for(s=0;s<r.length;s++)a=r[s],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(s=0;s<r.length;s++)a=r[s],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var o=s.createContext({}),c=function(e){var t=s.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):n(n({},t),e)),a},u=function(e){var t=c(e.components);return s.createElement(o.Provider,{value:t},e.children)},m="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return s.createElement(s.Fragment,{},t)}},b=s.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),m=c(a),b=i,d=m["".concat(o,".").concat(b)]||m[b]||p[b]||r;return a?s.createElement(d,n(n({ref:t},u),{},{components:a})):s.createElement(d,n({ref:t},u))}));function d(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,n=new Array(r);n[0]=b;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l[m]="string"==typeof e?e:i,n[1]=l;for(var c=2;c<r;c++)n[c]=a[c];return s.createElement.apply(null,n)}return s.createElement.apply(null,a)}b.displayName="MDXCreateElement"},89497:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>n,default:()=>p,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var s=a(87462),i=(a(67294),a(3905));const r={tags:["rabbit","rabbitmq","disk","persistence","messagestore","msg_store","lazyqueues","classicqueues","amqp"]},n=void 0,l={unversionedId:"learn-in-public/Engineering/RabbitMQ/RabbitMQ - Disk Persistence",id:"learn-in-public/Engineering/RabbitMQ/RabbitMQ - Disk Persistence",title:"RabbitMQ - Disk Persistence",description:"RabbitMQ is the one of the oldest messaging brokers out there in the wild - thus his code has evolved a lot in the past 10 years - within this evolution their persistence mechanism were heavily altered. From heavily memory-based to persisting messages directly to disk, the disk persistence changed through queue implementations and message store versions.",source:"@site/docs/learn-in-public/1. Engineering/RabbitMQ/RabbitMQ - Disk Persistence.md",sourceDirName:"learn-in-public/1. Engineering/RabbitMQ",slug:"/learn-in-public/Engineering/RabbitMQ/RabbitMQ - Disk Persistence",permalink:"/docs/learn-in-public/Engineering/RabbitMQ/RabbitMQ - Disk Persistence",draft:!1,tags:[{label:"rabbit",permalink:"/docs/tags/rabbit"},{label:"rabbitmq",permalink:"/docs/tags/rabbitmq"},{label:"disk",permalink:"/docs/tags/disk"},{label:"persistence",permalink:"/docs/tags/persistence"},{label:"messagestore",permalink:"/docs/tags/messagestore"},{label:"msg_store",permalink:"/docs/tags/msg-store"},{label:"lazyqueues",permalink:"/docs/tags/lazyqueues"},{label:"classicqueues",permalink:"/docs/tags/classicqueues"},{label:"amqp",permalink:"/docs/tags/amqp"}],version:"current",frontMatter:{tags:["rabbit","rabbitmq","disk","persistence","messagestore","msg_store","lazyqueues","classicqueues","amqp"]},sidebar:"learn-in-public",previous:{title:"How to build RabbitMQ locally",permalink:"/docs/learn-in-public/Engineering/RabbitMQ/How to build RabbitMQ locally"},next:{title:"RabbitMQ - Federation Plugin",permalink:"/docs/learn-in-public/Engineering/RabbitMQ/RabbitMQ - Federation Plugin"}},o={},c=[{value:"Classic Queues Persistence",id:"classic-queues-persistence",level:2},{value:"What is the difference storage difference in Classic Queues V1 and V2?",id:"what-is-the-difference-storage-difference-in-classic-queues-v1-and-v2",level:3},{value:"Message Store Internally",id:"message-store-internally",level:2},{value:"Rabbit 3.12x",id:"rabbit-312x",level:2},{value:"After Rabbit 3.13x",id:"after-rabbit-313x",level:3},{value:"Compact",id:"compact",level:3}],u={toc:c},m="wrapper";function p(e){let{components:t,...a}=e;return(0,i.kt)(m,(0,s.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"RabbitMQ is the one of the oldest messaging brokers out there in the wild - thus his code has evolved a lot in the past 10 years - within this evolution their persistence mechanism were heavily altered. From heavily memory-based to persisting messages directly to disk, the disk persistence changed through queue implementations and message store versions."),(0,i.kt)("p",null,"(This podcast w/ Michael Klisisn and --- goes through some of the background history of Rabbit.) 10 Years of Rabbitmq - Spotify"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Note: We are talking here about durable queues and persistent messages , ie messages that are not lost when a node/broker restarts")),(0,i.kt)("h2",{id:"classic-queues-persistence"},"Classic Queues Persistence"),(0,i.kt)("p",null,"Rabbit Classic Queues V1 #classicqueues  - were designed on a time were SSDs were not the cheapest resource - so frequent disk IO ops were way more costly and slow. This led the messages to be stored entirely in-memory and only flushing some big messages."),(0,i.kt)("p",null,"As resources got cheaper, disk I/O became way cheaper - thus ",(0,i.kt)("em",{parentName:"p"},"Lazy Queues")," were born. A new ",(0,i.kt)("inlineCode",{parentName:"p"},"mode")," of queue which wrote messages into disk much earlier and frequently than the old approach - and since RabbitMQ is really memory sensitive due to #queuemessageindexes it heavily improved memory profile, overall throughput and resiliency whenever there's any message backlog."),(0,i.kt)("p",null,"Currently - as of today 3.13x -  all Classic V1 operates almost like ",(0,i.kt)("inlineCode",{parentName:"p"},"lazy")," queues."),(0,i.kt)("h3",{id:"what-is-the-difference-storage-difference-in-classic-queues-v1-and-v2"},"What is the difference storage difference in Classic Queues V1 and V2?"),(0,i.kt)("p",null,"The messages are pretty differently stored between version - since V1 was more memory-based it kept a bigger portion of messages in-memory.  Besides it, when V1 was ",(0,i.kt)("em",{parentName:"p"},"a thing"),"  we only had a ",(0,i.kt)("em",{parentName:"p"},"single")," message storage(2 actually but works as one) for the entire broker."),(0,i.kt)("p",null,"Classic V2 has different storage implementation, both at the queue index and at the message store."),(0,i.kt)("p",null,"This video from RMQ team showcases this has a lot of insight into this.\n(RMQ Team showing lazy, v2 and v1 queues)"),(0,i.kt)("h2",{id:"message-store-internally"},"Message Store Internally"),(0,i.kt)("p",null,"On #rabbitmq/rabbitmq-server repository, we can check the file ",(0,i.kt)("inlineCode",{parentName:"p"},"rabbit_msg_store")," which the logic to interact w/ the persistence layer.\nRMQ stores messages into (default to, but configurable via ...) 16MB ",(0,i.kt)("inlineCode",{parentName:"p"},"*.rqd")," files - these files are called #segmentfiles, which are basically a bunch of aggregated messages with a ",(0,i.kt)("inlineCode",{parentName:"p"},"ref count")," - ie, the amount of references through the queues."),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"We publish a message to a fanout exchange with 10 bindings - Thus 10 queues receives the messages. Rabbit only writes 1 message into disk - with a ref count of 10. As messages are acknowledged by a queue, the ref count gets decremented. As soon as the `ref count` reaches 0, it gets elected to be garbage collected.\n")),(0,i.kt)("p",null,"For the message storage to work properly, Rabbit has a couple of data structures and ETS Tables."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Message Location",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Fields: -..-"),(0,i.kt)("li",{parentName:"ul"},"This DS is responsible to keep information about where the message is located in the disk ??"),(0,i.kt)("li",{parentName:"ul"},"Is used in the msg store index"))),(0,i.kt)("li",{parentName:"ul"},"FileSummary",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"A data strucuture that "))),(0,i.kt)("li",{parentName:"ul"},"MessageStoreState (msstate) & ClientMessageStoreStage(client_msstate)",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"These guys keep the state of the message store")))),(0,i.kt)("h1",{id:"rabbitmq-disk-gc"},"RabbitMQ Disk GC"),(0,i.kt)("p",null,"ref(",(0,i.kt)("inlineCode",{parentName:"p"},"rabbit_msg_store")," from line 1654 - 1900) #diskgarbagecollection #diskgc"),(0,i.kt)("p",null,"Rabbit has a disk garbage collecting mechanism on ",(0,i.kt)("inlineCode",{parentName:"p"},"rabbit_msg_store_gc")," which truncates #segmentfiles whenever 50% of the ",(0,i.kt)("inlineCode",{parentName:"p"},"ref count")," is 0 - within 2 files. (add reference here from rabbit-internals)"),(0,i.kt)("h2",{id:"rabbit-312x"},"Rabbit 3.12x"),(0,i.kt)("h3",{id:"after-rabbit-313x"},"After Rabbit 3.13x"),(0,i.kt)("p",null,"commit: 32816c0a76abf29abdb522befd52e4168f608c16 - rabbitmq-server"),(0,i.kt)("p",null,"The GC entry point is the ",(0,i.kt)("inlineCode",{parentName:"p"},"maybe_gc")," function - this functions list all files from the message store, which are not locked, locks them and proceed to ",(0,i.kt)("inlineCode",{parentName:"p"},"rabbit_msg_store_gc:compact")),(0,i.kt)("p",null,"The Disk GC from RabbitMQ has 3 main operations, which are called via ",(0,i.kt)("inlineCode",{parentName:"p"},"rabbit_msg_store_gc")," that applies scheduling logic, proxying calls to ",(0,i.kt)("inlineCode",{parentName:"p"},"rabbit_msg_store")," - operations are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"delete"),(0,i.kt)("li",{parentName:"ul"},"truncate "),(0,i.kt)("li",{parentName:"ul"},"compact")),(0,i.kt)("h3",{id:"compact"},"Compact"),(0,i.kt)("p",null,"The compaction algorithm is a simple and naive ",(0,i.kt)("inlineCode",{parentName:"p"},"defragmentation")," algo."))}p.isMDXComponent=!0}}]);